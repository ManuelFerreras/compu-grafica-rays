# üìÇ Estructura general

```
ray_project/
‚îú‚îÄ‚îÄ main.py
‚îú‚îÄ‚îÄ window.py
‚îú‚îÄ‚îÄ scene_normal.py
‚îú‚îÄ‚îÄ scene_cpu.py
‚îú‚îÄ‚îÄ scene_gpu.py
‚îú‚îÄ‚îÄ camera.py
‚îú‚îÄ‚îÄ ray.py
‚îú‚îÄ‚îÄ hit.py
‚îú‚îÄ‚îÄ cube.py
‚îú‚îÄ‚îÄ model.py
‚îú‚îÄ‚îÄ texture.py
‚îú‚îÄ‚îÄ material.py
‚îú‚îÄ‚îÄ graphics.py
‚îú‚îÄ‚îÄ quad.py
‚îú‚îÄ‚îÄ raytracer.py
‚îî‚îÄ‚îÄ shaders/
    ‚îú‚îÄ‚îÄ sprite.vert
    ‚îú‚îÄ‚îÄ sprite.frag
    ‚îú‚îÄ‚îÄ raytracing.vert
    ‚îî‚îÄ‚îÄ raytracing.frag
```

---

# `main.py`

### ¬øQu√© hace?

Punto de entrada. Crea la ventana, la c√°mara y carga **una** de las escenas (`normal`, `cpu`, `gpu`).

### Bloques importantes

* **Constante `SCENE_TYPE`**

  ```python
  SCENE_TYPE = "gpu"
  ```

  * Selecciona el modo de evaluaci√≥n requerido por el profe.
  * Cambi√°s a `"normal"` o `"cpu"` para probar cada etapa.

* **Creaci√≥n de ventana y c√°mara**

  ```python
  win = AppWindow(...)
  cam = Camera()
  ```

  * `AppWindow` encapsula Pyglet + ModernGL.
  * `Camera` mantiene matrices y estado (posici√≥n, yaw/pitch).

* **Selector de escena**

  ```python
  if SCENE_TYPE == "normal": from scene_normal import SceneNormal; scene = SceneNormal(cam)
  elif SCENE_TYPE == "cpu":  from scene_cpu import SceneCPU;       scene = SceneCPU(cam)
  elif SCENE_TYPE == "gpu":  from scene_gpu import SceneGPU;       scene = SceneGPU(cam)
  ```

  * **Import diferido**: s√≥lo importamos lo que vamos a usar.
  * Pasamos **la misma** `Camera` a cualquier escena.

* **Seteo & loop**

  ```python
  win.set_scene(scene)
  pyglet.app.run()
  ```

  * `set_scene` configura ModernGL en la escena y llama a `start()`.
  * `pyglet.app.run()` inicia el loop de eventos.

---

# `window.py` (App Window + switch F1/F2/F3)

### ¬øQu√© hace?

Ventana de Pyglet + contexto ModernGL. Maneja input, resize y hot-swap de escenas.

### Bloques importantes

* **Contexto GL y teclado**

  ```python
  self.ctx = moderngl.create_context()
  self.keys = key.KeyStateHandler()
  self.push_handlers(self.keys)
  ```

  * Crea el contexto **OpenGL**.
  * KeyState para **WASD/QE** continuo.

* **`set_scene(scene)`**

  ```python
  self.scene = scene
  self.scene.ctx = self.ctx
  self.scene.start()
  self.scene.on_resize(self.width, self.height)
  ```

  * Enlaza el **contexto GL** a la escena.
  * **Orden correcto**: `start()` (crea recursos) ‚Üí `on_resize()` (ajusta viewport y matrices).

* **`_switch_scene(mode)`**

  ```python
  cam = self.scene.camera if (...) else Camera()
  new_scene = SceneNormal/SceneCPU/SceneGPU(cam)
  self.set_scene(new_scene)
  self.set_caption(...)
  ```

  * **Reusa la misma c√°mara** al cambiar de modo.
  * Cambia el t√≠tulo para que el profe vea el modo activo.

* **`on_draw()`**

  ```python
  self.ctx.clear(*self.clear_color)
  self.scene.render()
  ```

  * Limpia el framebuffer y delega el dibujo a la escena.

* **`update(dt)`**

  ```python
  if (WASD/QE presionadas) and hasattr(camera.move): camera.move(...)
  self.scene.update(dt)
  ```

  * Movimiento de c√°mara **si la escena lo soporta**.
  * Llama `update` para animaciones.

* **`on_key_press(F1/F2/F3)`**

  * Cambia **en vivo** entre modos de escena.

* **`on_mouse_press/drag`**

  * Normaliza a `u=x/width`, `v=y/height` para raycasting/luz.
  * Bot√≥n derecho + drag: `camera.look(dx, -dy)`.

---

# `camera.py`

### ¬øQu√© hace?

Mantiene FOV, aspecto, matrices **view/projection** e inversa. Mueve y rota la c√°mara. Genera rayos.

### Funciones y l√≠neas clave

* **Constructor**

  ```python
  self.position = vec3(0,1,3); self.target = vec3(0,1,0); self.up = vec3(0,1,0)
  self.yaw = -90.0; self.pitch = 0.0
  self.view = glm.lookAt(self.position, self.target, self.up)
  self.proj = glm.perspective(radians(fov), aspect, near, far)
  self.inv_view = glm.inverse(self.view)
  ```

  * Setup **FPS-like** (mirando -Z).
  * Guardamos la **inversa** para transformar rayos (c√°mara‚Üímundo).

* **`update_matrices()`**

  ```python
  forward = normalize(vec3(cos(yaw)*cos(pitch), sin(pitch), sin(yaw)*cos(pitch)))
  self.target = self.position + forward
  self.view   = glm.lookAt(self.position, self.target, self.up)
  self.proj   = glm.perspective(...)
  self.inv_view = glm.inverse(self.view)
  ```

  * Recalcula matrices tras mover/rotar.

* **Cielo**

  ```python
  set_sky_colors(top, bottom)
  get_sky_gradient(h)  # interpola entre bottom-top
  ```

  * Para el **fondo** en normal/CPU.

* **`raycast(u,v)`**

  ```python
  x_ndc = 2u-1; y_ndc = 2v-1
  dir_cam = normalize(vec3(x_ndc*aspect*tan(fov/2), y_ndc*tan(fov/2), -1))
  dir_world = normalize(mat3(inv_view) * dir_cam)
  return Ray(position, dir_world)
  ```

  * Convierte **coordenadas de pantalla** en **rayo en mundo**.

* **Movimiento / Mirada**

  ```python
  move(forward_amt, right_amt, up_amt, dt)  # WASD/QE
  look(dyaw, dpitch)                        # mouse
  ```

  * `forward` plano XZ, `right = cross(forward, up)`.

---

# `ray.py`

### ¬øQu√© hace?

Representa un **rayo** con origen y direcci√≥n **normalizada**.

### Bloques importantes

* **Encapsulaci√≥n**

  ```python
  self.__origin, self.__direction
  @property def origin/direction ...
  ```

  * Mantiene invariante: la direcci√≥n siempre est√° normalizada.

* **Ecuaci√≥n del rayo**

  ```python
  P(t) = origin + t * direction
  ```

  * Usada conceptualmente en intersecciones.

---

# `hit.py`

### ¬øQu√© hace?

Define el **resultado** de un hit y las **cajas** (AABB/OBB) para colisiones.

### Clases y l√≠neas clave

* **`HitResult`**

  ```python
  hit: bool; t_near: float; t_far: float
  ```

  * si `hit==True`, `t_near` es la entrada del rayo.

* **`HitBox` (AABB)**

  ```python
  check_hit(origin, direction):
      # m√©todo de los Slabs
      for axis in x, y, z:
          if direction[axis] ‚âà 0: fuera? ‚Üí miss
          else: t1, t2 = (min-max - origin)/direction
                tmin = max(tmin, min(t1,t2))
                tmax = min(tmax, max(t1,t2))
      hit = tmax >= max(tmin, 0)
  ```

  * **Slab Method**: intersecci√≥n con planos paralelos por eje.

* **`HitBoxOBB` (caja orientada)**

  ```python
  # obtener invM del objeto
  oL = invM * origin
  pL = invM * (origin + direction)
  dL = normalize(pL - oL)
  # aplicar Slabs en espacio LOCAL
  ```

  * Transformamos el rayo al **espacio local** ‚Üí la caja vuelve a ser **AABB**.

---

# `cube.py`

### ¬øQu√© hace?

Modelo simple + hitbox OBB.

### Bloques importantes

* **Estado transform**

  ```python
  position, rotation(x,y,z), scale
  ```

* **`get_model_matrix()`**

  ```python
  T = translate(position)
  R = rotX * rotY * rotZ
  S = scale(scale)
  M = T * R * S
  ```

  * Orden t√≠pico **TRS**.

* **`check_hit(origin, direction)`**

  ```python
  self.hitbox.check_hit(origin, direction)
  ```

  * Delega en **AABB** o **OBB** seg√∫n la implementaci√≥n.

---

# `model.py`

### ¬øQu√© hace?

Abstracci√≥n de malla (v√©rtices, layout). Sirve para `Cube`/`Quad` si lo us√°s para GPU tradicional.

### Bloques importantes

* **`Vertex` / `VertexLayout`**

  * Estructuras para VBO/VAO: posici√≥n, normal, uv.

* **`Model`**

  * Administra buffers, draw call (si hubieras hecho raster tradicional).

> En este proyecto renderizamos por **Raytracing**, as√≠ que `Model` es de soporte y para el **Quad**.

---

# `texture.py`

### ¬øQu√© hace?

Maneja im√°genes en **CPU** y su conversi√≥n a bytes para la **GPU**.

### Bloques importantes

* **`ImageData(w,h,channels=3)`**

  ```python
  self.pixels = np.zeros((h, w, channels), dtype=np.uint8)
  ```

  * Buffer CPU que llenamos desde el **RayTracer**.

* **`get_bytes()`**

  ```python
  return self.pixels.tobytes(order="C")
  ```

  * Lo sube **Graphics** a una textura OpenGL.

---

# `material.py`

### ¬øQu√© hace?

Agrupa **shaders** + **texturas** + **uniforms**.
(En este pipeline lo usamos poco porque pintamos con shaders especializados de ray).

---

# `graphics.py`

### ¬øQu√© hace?

Capa de **ModernGL**: carga shaders, crea **quad fullscreen** y permite actualizar **textura**.

### Bloques importantes

* **`load_program_from_files(vs_path, fs_path)`**

  ```python
  v_src = open(vs).read(); f_src = open(fs).read()
  self.prog = self.ctx.program(vertex_shader=v_src, fragment_shader=f_src)
  ```

  * Compila y linkea **GLSL**.

* **`create_fullscreen_quad()`**

  ```python
  # Vertex buffer con dos tri√°ngulos que cubren la pantalla
  in_pos: (-1,-1),(1,-1),(1,1), (-1,-1),(1,1),(-1,1)
  in_uv:  (0,0),(1,0),(1,1), (0,0),(1,1),(0,1)
  self.vao = self.ctx.vertex_array(self.prog, [(vbo, "2f 2f", "in_pos","in_uv")])
  # Crea textura 2D vac√≠a que luego se actualiza
  self.texture = self.ctx.texture((2,2), components=3)
  ```

  * El **quad** es donde mostramos la textura (sea CPU o GPU).

* **`update_texture(w, h, bytes_ )`**

  ```python
  if size cambi√≥ -> recrea texture
  texture.write(bytes_)
  ```

  * Sube el **frame** generado por CPU **o** cualquier imagen.

* **`draw()`**

  ```python
  if self.texture in prog: bind(0); set sampler uniform; self.vao.render()
  ```

  * Dibuja el quad con la textura activa.

---

# `quad.py`

### ¬øQu√© hace?

Ayudante para crear la geometr√≠a del **quad** (si lo us√°s fuera de `Graphics`).

---

# `raytracer.py` (CPU)

### ¬øQu√© hace?

Genera, por **CPU**, la imagen p√≠xel a p√≠xel (lento pero exacto) y la devuelve como `ImageData`.

### Bloques importantes

* **Constructor**

  ```python
  self.camera = camera
  self.objects = objects
  ```

* **`render(width, height)`**

  ```python
  img = ImageData(width, height, 3)
  for j in range(height):
    for i in range(width):
       u = (i+0.5)/width; v = (j+0.5)/height
       ray = camera.raycast(u,v)
       color = self.trace(ray)
       img.pixels[j,i,:] = (color*255).astype(np.uint8)
  return img
  ```

  * **Muestreo** centro del p√≠xel.
  * **Gamma**: simple/clamp (seg√∫n versi√≥n).

* **`trace(ray)`**

  ```python
  # testea contra todos los objetos
  # si impacta ‚Üí color rojo (versi√≥n m√≠nima) o shading b√°sico
  # si no ‚Üí color de cielo (camera.get_sky_gradient(dir.y))
  ```

  * Aqu√≠ est√° la **l√≥gica** de colisiones y color (simplificada vs GPU).

---

# `scene_normal.py` (modo **NORMAL**)

### ¬øQu√© hace?

Renderiza **s√≥lo** un fondo (gradiente) y hace **Raycasting** al click para logs.

### Bloques importantes

* **`start()`**

  ```python
  self.objects = [Cube(...), ...] # para picking
  self.gfx = Graphics(self.ctx)
  self.gfx.load_program_from_files("sprite.vert","sprite.frag")
  self.gfx.create_fullscreen_quad()
  self._upload_sky_texture(w,h)
  ```

  * **No hay** raytracing.

* **`_upload_sky_texture(w,h)`**

  ```python
  rows[j] = camera.get_sky_gradient(v) * 255
  self.gfx.update_texture(w, h, img.get_bytes())
  ```

  * Genera el **gradiente** en CPU y lo sube a GPU.

* **`on_resize()`**

  ```python
  self._tex_w = max(320, width//2)
  self._upload_sky_texture(...)
  ```

  * Regenera el fondo a resoluci√≥n proporcional.

* **`on_mouse_click()`**

  ```python
  ray = camera.raycast(u, v)
  for obj in objects: res = obj.check_hit(...)
  print("[Hit] Nombre" or "[Miss]")
  ```

  * Demuestra **Raycasting**.

---

# `scene_cpu.py` (modo **CPU**)

### ¬øQu√© hace?

Usa `RayTracer` para generar una imagen en **baja resoluci√≥n interna** y la sube como textura al quad. Refresca cada ~0.15 s o cuando rota un cubo.

### Bloques importantes

* **Estado**

  ```python
  render_scale=0.33
  _render_dt=0.15
  _needs_redraw=True
  ```

  * Baja resoluci√≥n para **rendir**.
  * Limita el **refresco** para no recalcular cada frame.

* **`start()`**

  ```python
  self.objects = [...]
  self._raytracer = RayTracer(self.camera, self.objects)
  self.gfx = Graphics(self.ctx); self.gfx.load_program_from_files("sprite.vert","sprite.frag")
  self.gfx.create_fullscreen_quad()
  self._resize_internal(...); self._render_to_texture()
  ```

  * Crea todo y **renderiza** el primer frame.

* **`update(dt)`**

  ```python
  rotate cube B; self._needs_redraw = True
  if _needs_redraw and _acc >= _render_dt: _render_to_texture()
  ```

  * Re-render **cuando hace falta**.

* **`_render_to_texture()`**

  ```python
  img = self._raytracer.render(self.fb_width, self.fb_height)
  self.gfx.update_texture(...)
  ```

  * Pinta el resultado del **RayTracer** en el quad.

---

# `scene_gpu.py` (modo **GPU**)

### ¬øQu√© hace?

Dibuja el quad fullscreen y corre un **fragment shader** que **raytracea**: para cada p√≠xel, genera el rayo, intersecta OBBs y sombrea.

### Bloques importantes

* **`start()`**

  ```python
  self.objects = [Cube(...), ...]
  self.gfx = Graphics(self.ctx)
  self.gfx.load_program_from_files("raytracing.vert","raytracing.frag")
  self.gfx.create_fullscreen_quad()
  ```

  * Carga shader **de raytracing**.

* **Uniforms en `render()`**

  ```python
  prog["u_cam_pos"].value = (cam.pos.x, cam.pos.y, cam.pos.z)
  prog["u_fov_y"].value   = cam.fov_deg
  prog["u_aspect"].value  = cam.aspect
  prog["u_inv_view"].write(mat4_to_bytes(camera.inv_view))
  prog["u_sky_top/bottom"].value = ...
  prog["u_light_dir"].value = normalize(-0.5,1,-0.7)
  ```

  * Pasa **c√°mara**, **cielo** y **luz**.

* **Modelos y colores como **arrays**:**

  ```python
  prog["u_num_objs"].value = num
  prog["u_model"].write( concat(16 mat4 en bytes) )
  prog["u_color"].write( concat(16 vec4 en bytes) )
  ```

  * **Subimos el array completo** (evita `KeyError: 'u_model[0]'`/`u_color[0]` con algunos drivers).

* **`on_mouse_click()`**

  * Mantiene **picking** por CPU (para logs), independiente del shader.

---

# `shaders/sprite.vert` y `sprite.frag`

### ¬øQu√© hacen?

Shader m√≠nimo para dibujar una **textura 2D** (fondo normal / resultado CPU) en un quad fullscreen.

* **Vertex**: pasa posiciones y UV al fragment.
* **Fragment**: samplea la textura y la muestra.

---

# `shaders/raytracing.vert`

### ¬øQu√© hace?

S√≥lo **pasa las UV** y emite `gl_Position` para el quad.

```glsl
layout(location=0) in vec2 in_pos;   // -1..1
layout(location=1) in vec2 in_uv;    // 0..1
out vec2 v_uv;
v_uv = in_uv; gl_Position = vec4(in_pos,0,1);
```

---

# `shaders/raytracing.frag`

### ¬øQu√© hace?

**Aqu√≠ vive el raytracer en GPU**. Para cada p√≠xel:

1. Genera rayo en c√°mara.
2. Lo transforma a mundo.
3. Intersecta con todos los objetos (OBB ‚Üí inv(M)*rayo).
4. Si impacta: calcula **Lambert** (difuso + ambiente).
5. Si no: usa **cielo**.

### Uniforms importantes

```glsl
uniform vec3  u_cam_pos;
uniform float u_fov_y, u_aspect;
uniform mat4  u_inv_view;

uniform vec3 u_sky_top, u_sky_bottom;

const int MAX_OBJECTS=16;
uniform int  u_num_objs;
uniform mat4 u_model[MAX_OBJECTS];
uniform vec4 u_color[MAX_OBJECTS];

uniform vec3 u_light_dir;
```

* **Array de mat4/vec4** subidos como **bloques** desde Python.

### Generaci√≥n del rayo

```glsl
float tanHalf = tan(radians(u_fov_y)*0.5);
float x = 2*v_uv.x-1, y = 2*v_uv.y-1;
vec3 dir_cam = normalize(vec3(x*u_aspect*tanHalf, y*tanHalf, -1));
vec3 dir_world = normalize(mat3(u_inv_view)*dir_cam);
vec3 origin_world = u_cam_pos;
```

### Intersecci√≥n con OBB (v√≠a local)

```glsl
mat4 M = u_model[i], invM = inverse(M);
vec3 oL = (invM * vec4(origin_world,1)).xyz;
vec3 dL = normalize((invM * vec4(origin_world+dir_world,1)).xyz - oL);
float tNear = slabIntersectAABB(oL, dL, vec3(-0.5), vec3(0.5), tFar);
```

### Slab Method (n√∫cleo)

```glsl
// por eje X/Y/Z: acumula tmin/tmax; si tmin>tmax ‚Üí miss
```

### Sombreado Lambert

```glsl
// normal por cara en local (compara Hit con ¬±0.5 por eje)
vec3 nL = (¬±1,0,0) o (0,¬±1,0) o (0,0,¬±1)
vec3 nW = normalize(mat3(M) * nL)
float diff = max(dot(nW, normalize(u_light_dir)), 0.0)
vec3 col = base * (0.25 + 0.75 * diff) // 25% ambiente
```

### Cielo

```glsl
vec3 sky = mix(u_sky_bottom, u_sky_top, clamp(dir_world.y*0.5+0.5, 0,1));
```

---

# üß™ ¬øC√≥mo justificar/demostrar cada parte en un oral?

* **Rayos**: abrir `ray.py` ‚Üí `Ray(origin, direction)` normalizada.
* **Raycasting**: F1 (normal), click ‚Üí consola imprime el cubo (`scene_normal.py::on_mouse_click`).
* **CPU**: F2 (cpu), mover la c√°mara o rotar cubo ‚Üí ver refresco cada ~0.15 s; explicar `raytracer.py::render`.
* **GPU**: F3 (gpu), mover c√°mara y ver sombreado en tiempo real; mostrar `u_model` y `u_color` subidos como **arrays**.
* **OBB**: en shader, rayo transformado por `inverse(model)` ‚Üí Slab en local.
* **Matrices**: `camera.inv_view` enviado a shader para pasar de c√°mara a mundo.
* **Iluminaci√≥n**: Lambert (difuso) + 25% ambiente en fragment.
* **Switch de escenas**: F1/F2/F3 en `window.py::on_key_press` ‚Äî el profe lo ve en vivo.

---

# üß∑ Frases cortas para cerrar cada tema (estilo defensa)

* **Ray**: ‚ÄúEs una recta param√©trica; con `t` medimos distancias.‚Äù
* **Raycasting**: ‚ÄúLanzo 1 rayo por click para saber qu√© objeto toqu√©.‚Äù
* **Raytracing**: ‚ÄúLanzo 1 rayo por p√≠xel para decidir el color.‚Äù
* **CPU vs GPU**: ‚ÄúEn GPU paralelizo el c√°lculo por p√≠xel; en CPU es secuencial.‚Äù
* **AABB/OBB**: ‚ÄúSi transformo el rayo con `inverse(model)`, el OBB se vuelve AABB local.‚Äù
* **Slab**: ‚ÄúAjusto `tmin/tmax` por eje; si `tmin>tmax`, no hubo intersecci√≥n.‚Äù
* **Matrices**: ‚ÄúModel ubica el objeto; View mira; Projection da perspectiva; Inverse View sirve para transformar rayos.‚Äù
* **Shader**: ‚ÄúEl fragment calcula el rayo, intersecta y sombrea; si no pega, cielo.‚Äù
